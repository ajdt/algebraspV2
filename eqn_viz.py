#!/usr/bin/env python
#
# Author:	Armando Diaz Tolentino <ajdt@cs.washington.edu> 
#
# Desc:		A simple visualizer for the equations generated by the ASP program, eqn_generator.lp
#
# NOTE: 
#		requires asp output in json format. As of gringo4 this is possible with
#		clingo --outf=2 <gringo_file.lp>
#		
#		expects output from stdin, pipe clingo output to this program

import sys
import json
import re
import sympy as sp
from collections import defaultdict
import pdb
from pyparsing import Word, alphas, nums, ParseException


# values is a list of dictionaries, each dictionary contains one solution.
# each dictionary has one key called 'Value' which refers to a list of predicates and their values

int_parser		=  Word(nums +'-')
rat_parser		=  'rational(' + Word(nums +'-') + ',' + Word(nums +'-') + ')'
node_parser		= 'node(' + Word(nums) + ',' + Word(alphas) + ')'
mono_parser_int = 'monomOf(' + node_parser + ',' + int_parser +',' + Word(nums) +')'
mono_parser_rat = 'monomOf(' + node_parser + ',' + rat_parser +',' + Word(nums) +')'
type_parser		= 'nodeType(' + node_parser + ',' + Word(alphas) + ')'
oper_parser		= 'nodeOper(' + node_parser + ',' + Word(alphas) + ')'
child_parser 	= 'activeChild(' + node_parser + ',' + node_parser +')'
op_symbols 		= {'add' : '+' , 'div' : '/' , 'mul' : '*' }

def getMonoMapping():
	max_coeff, max_deg	= 5, 3
	key = lambda c, d : c*10+d
	value = lambda c, d : str(c) + 'x^' + str(d)
	coeffs, degrees = range(-1*max_coeff, max_coeff+1), range(max_deg+1)
	mapping = {}
	for c in coeffs:
		for d in degrees:
			mapping[key(c,d)] = value(c,d)
	for c1 in coeffs:
		for c2 in coeffs:
			for d in degrees:
				mapping[ key(c1+c2, d) ] = value(c1+c2, d)
				mapping[ key(c1*c2, d) ] = value(c1*c2, d)
	return mapping

MONO_MAPPINGS = getMonoMapping()

def onFail(x,y,z,w):
	return None

# set the fail action for each parser, otherwise throw exception
all_parsers = [int_parser, rat_parser, child_parser, node_parser, mono_parser_int, mono_parser_rat, type_parser, oper_parser]
for parser in all_parsers:
	parser.failAction = onFail

def findParserMatchingPredicate(predicate):
	for parser in all_parsers:
		try:
			parse_output = parser.parseString(predicate)
		except ParseException:
			continue
		return (parser, parse_output)
	return (None, [])

def formEqnString(predicates_list):
	# one dictionary per predicate type
	types, operator			= {}, {} 		# key is node id in all cases
	mono					= defaultdict(list)
	children 				= defaultdict(list)

	# parse predicate list for info first
	for predicate in predicates_list:
		match, parse = findParserMatchingPredicate(predicate)
		if match == node_parser or match == int_parser or match == rat_parser:
			continue
		elif match == mono_parser_int:
			node = ''.join(parse[1:6])
			monoID = int(parse[7])
			mono[node].append(monoID)
		elif match == mono_parser_rat:
			node = ''.join(parse[1:6])
			num, denom = parse[8], parse[10]
			coef = num + '/' + denom
			deg = parse[13]
			mono[node].append(coef + 'x^' + deg)
		elif match == type_parser:
			node = ''.join(parse[1:6])
			node_type, _ = filter(lambda x : x != ',', parse[6:])
			types[node] = node_type
		elif match == oper_parser:
			node = ''.join(parse[1:6])
			node_oper, _ = filter(lambda x : x != ',', parse[6:])
			operator[node] = node_oper
		elif match == child_parser:
			parent = ''.join(parse[1:6])
			child = ''.join(parse[7:12])
			children[parent].append(child)
		else :
			continue
	#print 'types', types, '\n\n'
	#print 'operator', operator, '\n\n'
	#print 'mono', mono, '\n\n'
	#print 'children', children, '\n\n'
	# print 
	return eqnString(types, operator, mono, children)

# form the full equation string given dictionaries with data
def eqnString(types, operator,mono, children, in_latex=False):
	left	= formPolyString(types, operator,mono, children, 'node(0,left)')
	right	= formPolyString(types, operator,mono, children, 'node(0,right)')
	if in_latex:
		string =  '$$' + sp.latex( sp.sympify(left, evaluate=False)) + '=' + sp.latex( sp.sympify(right, evaluate=False)) + '$$'
	else:
		string = left[1:-1] + '=' + right[1:-1] # NOTE: slicing to avoid outermost parens
	#print string
	return string
	

def formPolyString(types, operator, mono, children, root):
	if types[root] == 'poly':
		return '(' + makePolynomial(root, mono) + ')'

	child_strings = []
	for child in children[root]:
		child_strings.append( formPolyString(types, operator, mono, children, child) )
	return '(' + op_symbols[operator[root]].join(child_strings) + ')'

def makePolynomial(nodeName, mono):
	monomials = [ MONO_MAPPINGS[m]  for m in mono[nodeName] ]
	return '+'.join(monomials)

def main():
	clasp_output = ''.join(sys.stdin.xreadlines())
	decoded = json.loads(clasp_output)
	all_soln = decoded['Call'][0]['Witnesses']
	for solution in all_soln:
		print formEqnString(solution['Value'])

if __name__ == "__main__":
	main()
