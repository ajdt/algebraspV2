% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file contains all the rules used to solve an equation
% generated by eqn_generator.lp
%
% each rule's section contains both the condtions for the rule to fire,
% and the actions to perform if the rule is fired.
%

% helpers:

% node and integer properties
_notZero(Poly, S)									:-	_holds(Poly, _field(monomof, MonomID), S), not _zeroMonom(MonomID). 
_isZero(Poly, S)									:-	_holds(Poly, _field(nodetype, poly), S),
														not _notZero(Poly,S).
_unequal(Poly1, Poly2, S)							:-	_holds(Poly1, _field(monomof, MonomID), S),
														_holds(Poly2, _field(active), S),
														not _holds(Poly2, _field(monomof, MonomID), S),
														Poly1 != Poly2.
_unequal(Poly2, Poly1, S)							:-	_unequal(Poly1, Poly2, S).

% manipulating nodes
_deleteNode(Node, S)								:-	_deleteNodeAndChildren(Node, S).
_deleteNodeAndChildren(Child, S)					:-	_deleteNodeAndChildren(Node, S),
														_holds(Node, _field(activechild, Child), S).
_remove(Node, Field, S)								:-	_deleteNode(Node, S),
														_holds(Node, Field, S).

													% inheriting from 1
_introduce(Frac, _field(nodetype, poly), S) 		:-	_inheritFromOne(Frac, S).
_introduce(Frac, _field(monomof, 10), S) 			:-	_inheritFromOne(Frac, S).
_introduce(Frac, _field(numterms, 1), S)			:-	_inheritFromOne(Frac, S).
_introduce(Frac, _field(active), S)					:-	_inheritFromOne(Frac, S).

% deleteChildNode -- delete subtree rooted at child position
_deleteNodeAndChildren(Child, S)					:-	_deleteChildNode(Parent, Child, S).
_remove(Parent, _field(activechild, Child), S) 		:-	_deleteChildNode(Parent, Child, S).
_update(Parent, _field(numchildren, Children - 1), S) 
													:-	_deleteChildNode(Parent, Child, S),
														_holds(Parent, _field(numchildren, Children), S).
%================================================================================
% addCommonTerms: a*x^b + c*x^b ----> (a+c)*x^b, 2 Cases
%================================================================================
% 						### RULE CONDITIONS ###
% there's an add poly node with two children that are monomials of the same degree
_applicable(_action(addCommTerms, _data(Poly, MonoID1, MonoID2)), S)
													:-	_holds(Poly, _field(monomof, MonoID1), S),
														_holds(Poly, _field(monomof, MonoID2), S),
														_sameDeg(MonoID1, MonoID2).
% 						### APPLYING THE RULE ###
% add the two monomials together, and introduce their sum
_introduce(Poly, _field(monomof,Sum), S) 	
													:-	_doAction(_action(addCommTerms, _data(Poly, Mono1, Mono2)), S),
														_monoSum(Mono1, Mono2, Sum).
% remove old monomials
_remove(Poly, _field(monomof,Mono1), S) 	
													:-	_doAction(_action(addCommTerms, _data(Poly, Mono1, Mono2)), S).
_remove(Poly, _field(monomof,Mono2), S) 	
													:-	_doAction(_action(addCommTerms, _data(Poly, Mono1, Mono2)), S).


%================================================================================
%================================================================================

%================================================================================
% addIdentity: a*x^b + 0 ----> a*x^b 
%================================================================================
% 						### RULE CONDITIONS ###
%
_applicable(_action(addIdent, _data(Poly)), S)		:-	_holds(Poly, _field(monomof, MonoID), S),
														_zeroMonom(MonoID), % has more than one child
														not _holds(Poly, _field(numterms, 1), S). % has more than one child
% 						### APPLYING THE RULE ###
1 { _remove(Poly, _field(monomof, MonoID), S) :  	
									_holds(Poly, _field(monomof, MonoID), S),
									_zeroMonom(MonoID) } 1
													:-	_doAction(_action(addIdent, _data(Poly)), S).
														
														
% delete the monomial and update term count
_update(Poly, _field(numterms, Terms - 1), S)		:-	_doAction(_action(addIdent, _data(Poly)), S),
														_holds(Poly, _field(numterms, Terms), S).
% 						### APPLYING THE RULE ###
% add the two monomials together, and introduce their sum
%================================================================================
%================================================================================

%================================================================================
% divideInverse: a*x^b / a*x^b ----> 1
%================================================================================
% 						### RULE CONDITIONS ###
%
_applicable(_action(divInverse, _data(Frac)), S)	:-	_holds(Frac, _field(numer, Num), S),
														_holds(Frac, _field(denom, Denom), S),
														not _isZero(Denom,S),
														not _isZero(Num,S),
														not _unequal(Num, Denom, S).

	
% 						### APPLYING THE RULE ###
_deleteNodeAndChildren(Frac, S) 					:-	_doAction(_action(divInverse, _data(Frac)), S).
_inheritFromOne(Frac, S) 							:-	_doAction(_action(divInverse, _data(Frac)), S).

%================================================================================
% multIdentity: a*x^b * 1 ----> a*x^b
%================================================================================
% 						### RULE CONDITIONS ###
%
_applicable(_action(multIdent, _data(MultNode, ChildIdent)), S)
													:-	_holds(MultNode, _field(activechild, ChildIdent),S),
														_holds(MultNode, _field(nodeoper, mul), S),
														_holds(MultNode, _field(numchildren, Children), S),
														Children > 1,
														_holds(ChildIdent, _field(numterms, 1), S),
														_holds(ChildIdent, _field(monomof, 10), S).
% 						### APPLYING THE RULE ###
_deleteChildNode(MultNode, ChildIdent, S) 			:-	_doAction(_action(multIdent, _data(MultNode, ChildIdent)), S).

% code for removing a child from a tree

:- not action(divInverse).
