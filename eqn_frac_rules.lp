% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file contains fraction rules used to solve an equation that is
% generated by eqn_generator.lp
%

%================================================================================
% fracCancel: A*C/(B*C) --> A/B
%================================================================================
% 						### RULE CONDITIONS ###
_applicable(_action(fracCancel, _data(CTermTop, CTermBottom)), S)	
								:-	_holds(DivNode, _field(nodeoper, div), S),
									_holds(DivNode, _field(numer, Num), S),
									_holds(DivNode, _field(denom, Denom), S),
									_holds(Num, _field(nodeoper, mul), S),
									_holds(Denom, _field(nodeoper, mul), S),
									% constraint for num children?
									_holds(Num, _field(activechild, CTermTop), S),
									_holds(Denom, _field(activechild, CTermBottom), S),
									not _unequal(CTermTop, CTermBottom, S).

% 						### APPLYING THE RULE ###
_deleteChildNode(Num, CTermTop, S)		:-	_doAction(_action(fracCancel, _data(CTermTop, CTermBottom)), S),
											_holds(Num, _field(activechild, CTermTop), S).
_deleteChildNode(Denom, CTermBottom, S)	:-	_doAction(_action(fracCancel, _data(CTermTop, CTermBottom)), S),
											_holds(Denom, _field(activechild, CTermBottom), S).
%================================================================================
%================================================================================

%================================================================================
% FracMult: (A/B)*(C/D) --> (A*C)/(B*D)
%================================================================================
% 						### RULE CONDITIONS ###
_applicable(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S)	
								:-	_opSubtree(MulNode, FracLeft, FracRight, mul, div, div, S),
									_holds(MulNode, _field(numchildren, 2), S). % TODO: temporary fix for bug where subtree has more than two children

% 						### APPLYING THE RULE ###
% make root node a fraction and set its numerator/denominator
_introduce(MulNode, _field(numer, FracLeft), S)		:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S).
_introduce(MulNode, _field(denom, FracRight), S)	:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S).
_update(MulNode, _field(nodeoper, div), S)			:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S).

% make left fraction the numerator 
_removeFracFields(FracLeft, S)						:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S).
_update(FracLeft, _field(nodeoper, mul), S)			:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S).

% make right fraction the numerator 
_removeFracFields(FracRight, S)						:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S).
_update(FracRight, _field(nodeoper, mul), S)		:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S).

% swap left denom and right num values to get correct products
_swapNodes(LeftDenom, RightNum, S)					:-	_doAction(_action(fracMult, _data(MulNode, FracLeft, FracRight)), S),
														_holds(FracLeft, _field(denom, LeftDenom), S),
														_holds(FracRight, _field(numer, RightNum), S).


%================================================================================
% AddfracSameDenom: A/B + C/B--> (A+C)/B
%================================================================================
%%_applicable(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S)	%%
								%%:-	_holds(PlusNode, _field(nodeoper, add), S),%%
									%%_holds(PlusNode, _field(activechild, DivLeft), S),%%
									%%_holds(PlusNode, _field(activechild, DivRight), S),%%
									%%_holds(DivLeft, _field(nodeoper, div), S),%%
									%%_holds(DivRight, _field(nodeoper, div), S),%%
									%%_holds(DivLeft, _field(denom, BTermLeft), S),%%
									%%_holds(DivRight, _field(denom, BTermRight), S),%%
									%%not _unequal(BTermLeft, BTermRight, S),%%
									%%_holds(DivLeft, _field(numer, NumLeft), S),%%
									%%_holds(DivRight, _field(numer, NumRight), S),%%
									%%_holds(NumLeft, _field(nodetype, poly), S),%%
									%%_holds(NumRight, _field(nodetype, poly), S).%%
								%%% 2 kids case%%
%%_update(PlusNode, _field(nodeoper, div), S)	:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S).%%
%%_introduce(PlusNode, _field(num, DivLeft), S)	:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S).%%
%%_introduce(PlusNode, _field(denom, DivRight), S)	:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S).%%

%%% denom %%
%%_deleteNodeAndChildren(DivRight, S)		:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S).%%
%%_inheritFrom(DivRight, BTermLeft, S)	:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S),%%
								%%_holds(DivRight, _field(denom, BTermLeft), S).%%
%%_deleteNodeAndChildren(DivLeft, S)		:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S).%%
%%_inheritFrom(DivLeft, NumLeft, S)	:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S),%%
										%%_holds(DivLeft, _field(numer, NumLeft), S).%%
%%_inheritFrom(DivLeft, NumRight, S)	:-	_doAction(_action(addFracSameDenom, _data(PlusNode, DivLeft, DivRight)), S),%%
										%%_holds(DivRight, _field(numer, NumRight), S).%%
%%%XXX: SUPER MEGA WARNING, numterms will be incorrect given the above!%%%


