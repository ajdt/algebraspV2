#!/usr/bin/env python
#
# Author:	Armando Diaz Tolentino <ajdt@cs.washington.edu> 
#
# Desc:		A simple visualizer for solution generated by
#			eqn_solver.lp to problems generated by eqn_generator.lp
#
# NOTE: 
#		requires asp output in json format. As of gringo4 this is possible with
#		clingo --outf=2 <gringo_file.lp>
#		
#		expects output from stdin, pipe clingo output to this program

import sys
import json
import re
from collections import defaultdict
from pyparsing import Word, alphas, nums, ParseException

# requried for generation, this file only parses predicates into steps
from eqn_viz import *


# values is a list of dictionaries, each dictionary contains one solution.
# each dictionary has one key called 'Value' which refers to a list of predicates and their values

def wrapField(field_name, field_parser):
	field_str = 'field(' + field_name + ','
	return field_str + field_parser + ')'
def wrapWithHolds(parser):
	return 'holds(' + node_parser + ',' + parser + ',' + Word(nums) + ')'

int_parser		=  Word(nums +'-')
rat_parser		=  'rational(' + Word(nums +'-') + ',' + Word(nums +'-') + ')'
int_monom		=	Word(nums + '-')
rat_monom		= 'monom(' + rat_parser + ',' + Word(nums) + ')'
node_parser		= 'node(' + Word(nums) + ',' + Word(alphas) + ')'

mono_parser_int =	wrapWithHolds(wrapField('monomof', int_monom))
mono_parser_rat =	wrapWithHolds(wrapField('monomof', rat_monom))
type_parser		=	wrapWithHolds(wrapField('nodetype', Word(alphas))) 
oper_parser		=	wrapWithHolds(wrapField('nodeoper', Word(alphas))) 
child_parser	=	wrapWithHolds(wrapField('activechild', node_parser)) 

op_symbols 		= {'add' : '+' , 'div' : '/' , 'mul' : '*' }

# set the fail action for each parser, otherwise throw exception
all_parsers = [child_parser, node_parser, mono_parser_int, mono_parser_rat, type_parser, oper_parser]

def findParserMatchingPredicate(predicate):
	for parser in all_parsers:
		try:
			parse_output = parser.parseString(predicate)
		except ParseException:
			continue
		return (parser, parse_output)
	return (None, [])

def defaultDictEmptyList():
	return defaultdict(list)
def shaveHoldsReturnStep(parse_list):
	step = int(parse_list[-2])
	node = ''.join(parse_list[1:6])
	aux = parse_list[7:-3]
	return (step, node, aux)

def formEqnString(predicates_list):
	# one dictionary per predicate type
	types, operator			= defaultdict(dict), defaultdict(dict) 		# key is node id in all cases
	mono					= defaultdict(defaultDictEmptyList)
	children 				= defaultdict(defaultDictEmptyList)
	steps					= set()

	# parse predicate list for info first
	for predicate in predicates_list:
		match, parse = findParserMatchingPredicate(predicate)
		#print parse
		step = None
		if match == node_parser or match == int_parser or match == rat_parser:
			continue
		elif match == mono_parser_int:
			step, node, aux = shaveHoldsReturnStep(parse)
			monoID = int(aux[1])
			mono[step][node].append(monoID)
		elif match == mono_parser_rat:
			step, node, aux = shaveHoldsReturnStep(parse)
			num, denom = aux[3], aux[5]
			coef = num + '/' + denom
			deg = aux[8]
			mono[step][node].append(coef + 'x^' + deg)
		elif match == type_parser:
			step, node, aux = shaveHoldsReturnStep(parse)
			node_type = aux[1]
			types[step][node] = node_type
		elif match == oper_parser:
			step, node, aux = shaveHoldsReturnStep(parse)
			node_oper = aux[1]
			operator[step][node] = node_oper
		elif match == child_parser:
			step, parent, aux = shaveHoldsReturnStep(parse)
			child = ''.join(aux[1:-1])
			children[step][parent].append(child)
		else :
			continue
		if step != None:
			steps.add(step)

	# create a string containing all solve steps
	eqn_steps = []
	fmt_step = lambda step_no, step: str(step_no) + ':' + step 
	for step in sorted(list(steps)):
		eqn_steps.append(fmt_step(step, eqnString(types[step], operator[step], mono[step], children[step])))

	return '\n'.join(eqn_steps + ['_' * 30] ) 

def main():
	clasp_output = ''.join(sys.stdin.xreadlines())
	decoded = json.loads(clasp_output)
	all_soln = decoded['Call'][0]['Witnesses']
	for solution in all_soln:
		print formEqnString(solution['Value'])

if __name__ == "__main__":
	main()
